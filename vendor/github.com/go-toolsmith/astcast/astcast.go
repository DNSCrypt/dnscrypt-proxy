// Code generated by astcast_generate.go; DO NOT EDIT

// Package astcast wraps type assertion operations in such way that you don't have
// to worry about nil pointer results anymore.
package astcast

import (
	"go/ast"
)

// A set of sentinel nil-like values that are returned
// by all "casting" functions in case of failed type assertion.
var (
	NilArrayType      = &ast.ArrayType{}
	NilBadExpr        = &ast.BadExpr{}
	NilBasicLit       = &ast.BasicLit{}
	NilBinaryExpr     = &ast.BinaryExpr{}
	NilCallExpr       = &ast.CallExpr{}
	NilChanType       = &ast.ChanType{}
	NilCompositeLit   = &ast.CompositeLit{}
	NilEllipsis       = &ast.Ellipsis{}
	NilFuncLit        = &ast.FuncLit{}
	NilFuncType       = &ast.FuncType{}
	NilIdent          = &ast.Ident{}
	NilIndexExpr      = &ast.IndexExpr{}
	NilInterfaceType  = &ast.InterfaceType{}
	NilKeyValueExpr   = &ast.KeyValueExpr{}
	NilMapType        = &ast.MapType{}
	NilParenExpr      = &ast.ParenExpr{}
	NilSelectorExpr   = &ast.SelectorExpr{}
	NilSliceExpr      = &ast.SliceExpr{}
	NilStarExpr       = &ast.StarExpr{}
	NilStructType     = &ast.StructType{}
	NilTypeAssertExpr = &ast.TypeAssertExpr{}
	NilUnaryExpr      = &ast.UnaryExpr{}
	NilAssignStmt     = &ast.AssignStmt{}
	NilBadStmt        = &ast.BadStmt{}
	NilBlockStmt      = &ast.BlockStmt{}
	NilBranchStmt     = &ast.BranchStmt{}
	NilCaseClause     = &ast.CaseClause{}
	NilCommClause     = &ast.CommClause{}
	NilDeclStmt       = &ast.DeclStmt{}
	NilDeferStmt      = &ast.DeferStmt{}
	NilEmptyStmt      = &ast.EmptyStmt{}
	NilExprStmt       = &ast.ExprStmt{}
	NilForStmt        = &ast.ForStmt{}
	NilGoStmt         = &ast.GoStmt{}
	NilIfStmt         = &ast.IfStmt{}
	NilIncDecStmt     = &ast.IncDecStmt{}
	NilLabeledStmt    = &ast.LabeledStmt{}
	NilRangeStmt      = &ast.RangeStmt{}
	NilReturnStmt     = &ast.ReturnStmt{}
	NilSelectStmt     = &ast.SelectStmt{}
	NilSendStmt       = &ast.SendStmt{}
	NilSwitchStmt     = &ast.SwitchStmt{}
	NilTypeSwitchStmt = &ast.TypeSwitchStmt{}
	NilComment        = &ast.Comment{}
	NilCommentGroup   = &ast.CommentGroup{}
	NilFieldList      = &ast.FieldList{}
	NilFile           = &ast.File{}
	NilPackage        = &ast.Package{}
)

// ToArrayType returns x as a non-nil *ast.ArrayType.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilArrayType.
func ToArrayType(x ast.Node) *ast.ArrayType {
	if x, ok := x.(*ast.ArrayType); ok {
		return x
	}
	return NilArrayType
}

// ToBadExpr returns x as a non-nil *ast.BadExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilBadExpr.
func ToBadExpr(x ast.Node) *ast.BadExpr {
	if x, ok := x.(*ast.BadExpr); ok {
		return x
	}
	return NilBadExpr
}

// ToBasicLit returns x as a non-nil *ast.BasicLit.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilBasicLit.
func ToBasicLit(x ast.Node) *ast.BasicLit {
	if x, ok := x.(*ast.BasicLit); ok {
		return x
	}
	return NilBasicLit
}

// ToBinaryExpr returns x as a non-nil *ast.BinaryExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilBinaryExpr.
func ToBinaryExpr(x ast.Node) *ast.BinaryExpr {
	if x, ok := x.(*ast.BinaryExpr); ok {
		return x
	}
	return NilBinaryExpr
}

// ToCallExpr returns x as a non-nil *ast.CallExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilCallExpr.
func ToCallExpr(x ast.Node) *ast.CallExpr {
	if x, ok := x.(*ast.CallExpr); ok {
		return x
	}
	return NilCallExpr
}

// ToChanType returns x as a non-nil *ast.ChanType.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilChanType.
func ToChanType(x ast.Node) *ast.ChanType {
	if x, ok := x.(*ast.ChanType); ok {
		return x
	}
	return NilChanType
}

// ToCompositeLit returns x as a non-nil *ast.CompositeLit.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilCompositeLit.
func ToCompositeLit(x ast.Node) *ast.CompositeLit {
	if x, ok := x.(*ast.CompositeLit); ok {
		return x
	}
	return NilCompositeLit
}

// ToEllipsis returns x as a non-nil *ast.Ellipsis.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilEllipsis.
func ToEllipsis(x ast.Node) *ast.Ellipsis {
	if x, ok := x.(*ast.Ellipsis); ok {
		return x
	}
	return NilEllipsis
}

// ToFuncLit returns x as a non-nil *ast.FuncLit.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilFuncLit.
func ToFuncLit(x ast.Node) *ast.FuncLit {
	if x, ok := x.(*ast.FuncLit); ok {
		return x
	}
	return NilFuncLit
}

// ToFuncType returns x as a non-nil *ast.FuncType.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilFuncType.
func ToFuncType(x ast.Node) *ast.FuncType {
	if x, ok := x.(*ast.FuncType); ok {
		return x
	}
	return NilFuncType
}

// ToIdent returns x as a non-nil *ast.Ident.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilIdent.
func ToIdent(x ast.Node) *ast.Ident {
	if x, ok := x.(*ast.Ident); ok {
		return x
	}
	return NilIdent
}

// ToIndexExpr returns x as a non-nil *ast.IndexExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilIndexExpr.
func ToIndexExpr(x ast.Node) *ast.IndexExpr {
	if x, ok := x.(*ast.IndexExpr); ok {
		return x
	}
	return NilIndexExpr
}

// ToInterfaceType returns x as a non-nil *ast.InterfaceType.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilInterfaceType.
func ToInterfaceType(x ast.Node) *ast.InterfaceType {
	if x, ok := x.(*ast.InterfaceType); ok {
		return x
	}
	return NilInterfaceType
}

// ToKeyValueExpr returns x as a non-nil *ast.KeyValueExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilKeyValueExpr.
func ToKeyValueExpr(x ast.Node) *ast.KeyValueExpr {
	if x, ok := x.(*ast.KeyValueExpr); ok {
		return x
	}
	return NilKeyValueExpr
}

// ToMapType returns x as a non-nil *ast.MapType.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilMapType.
func ToMapType(x ast.Node) *ast.MapType {
	if x, ok := x.(*ast.MapType); ok {
		return x
	}
	return NilMapType
}

// ToParenExpr returns x as a non-nil *ast.ParenExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilParenExpr.
func ToParenExpr(x ast.Node) *ast.ParenExpr {
	if x, ok := x.(*ast.ParenExpr); ok {
		return x
	}
	return NilParenExpr
}

// ToSelectorExpr returns x as a non-nil *ast.SelectorExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilSelectorExpr.
func ToSelectorExpr(x ast.Node) *ast.SelectorExpr {
	if x, ok := x.(*ast.SelectorExpr); ok {
		return x
	}
	return NilSelectorExpr
}

// ToSliceExpr returns x as a non-nil *ast.SliceExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilSliceExpr.
func ToSliceExpr(x ast.Node) *ast.SliceExpr {
	if x, ok := x.(*ast.SliceExpr); ok {
		return x
	}
	return NilSliceExpr
}

// ToStarExpr returns x as a non-nil *ast.StarExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilStarExpr.
func ToStarExpr(x ast.Node) *ast.StarExpr {
	if x, ok := x.(*ast.StarExpr); ok {
		return x
	}
	return NilStarExpr
}

// ToStructType returns x as a non-nil *ast.StructType.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilStructType.
func ToStructType(x ast.Node) *ast.StructType {
	if x, ok := x.(*ast.StructType); ok {
		return x
	}
	return NilStructType
}

// ToTypeAssertExpr returns x as a non-nil *ast.TypeAssertExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilTypeAssertExpr.
func ToTypeAssertExpr(x ast.Node) *ast.TypeAssertExpr {
	if x, ok := x.(*ast.TypeAssertExpr); ok {
		return x
	}
	return NilTypeAssertExpr
}

// ToUnaryExpr returns x as a non-nil *ast.UnaryExpr.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilUnaryExpr.
func ToUnaryExpr(x ast.Node) *ast.UnaryExpr {
	if x, ok := x.(*ast.UnaryExpr); ok {
		return x
	}
	return NilUnaryExpr
}

// ToAssignStmt returns x as a non-nil *ast.AssignStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilAssignStmt.
func ToAssignStmt(x ast.Node) *ast.AssignStmt {
	if x, ok := x.(*ast.AssignStmt); ok {
		return x
	}
	return NilAssignStmt
}

// ToBadStmt returns x as a non-nil *ast.BadStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilBadStmt.
func ToBadStmt(x ast.Node) *ast.BadStmt {
	if x, ok := x.(*ast.BadStmt); ok {
		return x
	}
	return NilBadStmt
}

// ToBlockStmt returns x as a non-nil *ast.BlockStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilBlockStmt.
func ToBlockStmt(x ast.Node) *ast.BlockStmt {
	if x, ok := x.(*ast.BlockStmt); ok {
		return x
	}
	return NilBlockStmt
}

// ToBranchStmt returns x as a non-nil *ast.BranchStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilBranchStmt.
func ToBranchStmt(x ast.Node) *ast.BranchStmt {
	if x, ok := x.(*ast.BranchStmt); ok {
		return x
	}
	return NilBranchStmt
}

// ToCaseClause returns x as a non-nil *ast.CaseClause.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilCaseClause.
func ToCaseClause(x ast.Node) *ast.CaseClause {
	if x, ok := x.(*ast.CaseClause); ok {
		return x
	}
	return NilCaseClause
}

// ToCommClause returns x as a non-nil *ast.CommClause.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilCommClause.
func ToCommClause(x ast.Node) *ast.CommClause {
	if x, ok := x.(*ast.CommClause); ok {
		return x
	}
	return NilCommClause
}

// ToDeclStmt returns x as a non-nil *ast.DeclStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilDeclStmt.
func ToDeclStmt(x ast.Node) *ast.DeclStmt {
	if x, ok := x.(*ast.DeclStmt); ok {
		return x
	}
	return NilDeclStmt
}

// ToDeferStmt returns x as a non-nil *ast.DeferStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilDeferStmt.
func ToDeferStmt(x ast.Node) *ast.DeferStmt {
	if x, ok := x.(*ast.DeferStmt); ok {
		return x
	}
	return NilDeferStmt
}

// ToEmptyStmt returns x as a non-nil *ast.EmptyStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilEmptyStmt.
func ToEmptyStmt(x ast.Node) *ast.EmptyStmt {
	if x, ok := x.(*ast.EmptyStmt); ok {
		return x
	}
	return NilEmptyStmt
}

// ToExprStmt returns x as a non-nil *ast.ExprStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilExprStmt.
func ToExprStmt(x ast.Node) *ast.ExprStmt {
	if x, ok := x.(*ast.ExprStmt); ok {
		return x
	}
	return NilExprStmt
}

// ToForStmt returns x as a non-nil *ast.ForStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilForStmt.
func ToForStmt(x ast.Node) *ast.ForStmt {
	if x, ok := x.(*ast.ForStmt); ok {
		return x
	}
	return NilForStmt
}

// ToGoStmt returns x as a non-nil *ast.GoStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilGoStmt.
func ToGoStmt(x ast.Node) *ast.GoStmt {
	if x, ok := x.(*ast.GoStmt); ok {
		return x
	}
	return NilGoStmt
}

// ToIfStmt returns x as a non-nil *ast.IfStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilIfStmt.
func ToIfStmt(x ast.Node) *ast.IfStmt {
	if x, ok := x.(*ast.IfStmt); ok {
		return x
	}
	return NilIfStmt
}

// ToIncDecStmt returns x as a non-nil *ast.IncDecStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilIncDecStmt.
func ToIncDecStmt(x ast.Node) *ast.IncDecStmt {
	if x, ok := x.(*ast.IncDecStmt); ok {
		return x
	}
	return NilIncDecStmt
}

// ToLabeledStmt returns x as a non-nil *ast.LabeledStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilLabeledStmt.
func ToLabeledStmt(x ast.Node) *ast.LabeledStmt {
	if x, ok := x.(*ast.LabeledStmt); ok {
		return x
	}
	return NilLabeledStmt
}

// ToRangeStmt returns x as a non-nil *ast.RangeStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilRangeStmt.
func ToRangeStmt(x ast.Node) *ast.RangeStmt {
	if x, ok := x.(*ast.RangeStmt); ok {
		return x
	}
	return NilRangeStmt
}

// ToReturnStmt returns x as a non-nil *ast.ReturnStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilReturnStmt.
func ToReturnStmt(x ast.Node) *ast.ReturnStmt {
	if x, ok := x.(*ast.ReturnStmt); ok {
		return x
	}
	return NilReturnStmt
}

// ToSelectStmt returns x as a non-nil *ast.SelectStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilSelectStmt.
func ToSelectStmt(x ast.Node) *ast.SelectStmt {
	if x, ok := x.(*ast.SelectStmt); ok {
		return x
	}
	return NilSelectStmt
}

// ToSendStmt returns x as a non-nil *ast.SendStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilSendStmt.
func ToSendStmt(x ast.Node) *ast.SendStmt {
	if x, ok := x.(*ast.SendStmt); ok {
		return x
	}
	return NilSendStmt
}

// ToSwitchStmt returns x as a non-nil *ast.SwitchStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilSwitchStmt.
func ToSwitchStmt(x ast.Node) *ast.SwitchStmt {
	if x, ok := x.(*ast.SwitchStmt); ok {
		return x
	}
	return NilSwitchStmt
}

// ToTypeSwitchStmt returns x as a non-nil *ast.TypeSwitchStmt.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilTypeSwitchStmt.
func ToTypeSwitchStmt(x ast.Node) *ast.TypeSwitchStmt {
	if x, ok := x.(*ast.TypeSwitchStmt); ok {
		return x
	}
	return NilTypeSwitchStmt
}

// ToComment returns x as a non-nil *ast.Comment.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilComment.
func ToComment(x ast.Node) *ast.Comment {
	if x, ok := x.(*ast.Comment); ok {
		return x
	}
	return NilComment
}

// ToCommentGroup returns x as a non-nil *ast.CommentGroup.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilCommentGroup.
func ToCommentGroup(x ast.Node) *ast.CommentGroup {
	if x, ok := x.(*ast.CommentGroup); ok {
		return x
	}
	return NilCommentGroup
}

// ToFieldList returns x as a non-nil *ast.FieldList.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilFieldList.
func ToFieldList(x ast.Node) *ast.FieldList {
	if x, ok := x.(*ast.FieldList); ok {
		return x
	}
	return NilFieldList
}

// ToFile returns x as a non-nil *ast.File.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilFile.
func ToFile(x ast.Node) *ast.File {
	if x, ok := x.(*ast.File); ok {
		return x
	}
	return NilFile
}

// ToPackage returns x as a non-nil *ast.Package.
// If ast.Node actually has such dynamic type, the result is
// identical to normal type assertion. In case if it has
// different type, the returned value is NilPackage.
func ToPackage(x ast.Node) *ast.Package {
	if x, ok := x.(*ast.Package); ok {
		return x
	}
	return NilPackage
}
