// Code generated by "go run ednsrr_generate.go"; DO NOT EDIT.

package dns

func (o *LLQ) Header() *Header          { return &Header{Name: "."} }
func (o *LLQ) Pseudo() bool             { return true }
func (o *REPORTING) Header() *Header    { return &Header{Name: "."} }
func (o *REPORTING) Pseudo() bool       { return true }
func (o *COOKIE) Header() *Header       { return &Header{Name: "."} }
func (o *COOKIE) Pseudo() bool          { return true }
func (o *NSID) Header() *Header         { return &Header{Name: "."} }
func (o *NSID) Pseudo() bool            { return true }
func (o *PADDING) Header() *Header      { return &Header{Name: "."} }
func (o *PADDING) Pseudo() bool         { return true }
func (o *EXPIRE) Header() *Header       { return &Header{Name: "."} }
func (o *EXPIRE) Pseudo() bool          { return true }
func (o *DAU) Header() *Header          { return &Header{Name: "."} }
func (o *DAU) Pseudo() bool             { return true }
func (o *DHU) Header() *Header          { return &Header{Name: "."} }
func (o *DHU) Pseudo() bool             { return true }
func (o *N3U) Header() *Header          { return &Header{Name: "."} }
func (o *N3U) Pseudo() bool             { return true }
func (o *TCPKEEPALIVE) Header() *Header { return &Header{Name: "."} }
func (o *TCPKEEPALIVE) Pseudo() bool    { return true }
func (o *EDE) Header() *Header          { return &Header{Name: "."} }
func (o *EDE) Pseudo() bool             { return true }
func (o *SUBNET) Header() *Header       { return &Header{Name: "."} }
func (o *SUBNET) Pseudo() bool          { return true }
func (o *ESU) Header() *Header          { return &Header{Name: "."} }
func (o *ESU) Pseudo() bool             { return true }
func (o *ZONEVERSION) Header() *Header  { return &Header{Name: "."} }
func (o *ZONEVERSION) Pseudo() bool     { return true }

// CodeToRR is a map of constructors for each EDNS0 RR type.
var CodeToRR = map[uint16]func() EDNS0{
	CodeLLQ:          func() EDNS0 { return new(LLQ) },
	CodeREPORTING:    func() EDNS0 { return new(REPORTING) },
	CodeCOOKIE:       func() EDNS0 { return new(COOKIE) },
	CodeNSID:         func() EDNS0 { return new(NSID) },
	CodePADDING:      func() EDNS0 { return new(PADDING) },
	CodeEXPIRE:       func() EDNS0 { return new(EXPIRE) },
	CodeDAU:          func() EDNS0 { return new(DAU) },
	CodeDHU:          func() EDNS0 { return new(DHU) },
	CodeN3U:          func() EDNS0 { return new(N3U) },
	CodeTCPKEEPALIVE: func() EDNS0 { return new(TCPKEEPALIVE) },
	CodeEDE:          func() EDNS0 { return new(EDE) },
	CodeSUBNET:       func() EDNS0 { return new(SUBNET) },
	CodeESU:          func() EDNS0 { return new(ESU) },
	CodeZONEVERSION:  func() EDNS0 { return new(ZONEVERSION) },
}

// RRToCode is the reverse of CodeToRR, implemented as a function.
func RRToCode(o EDNS0) uint16 {
	switch o.(type) {
	case *LLQ:
		return CodeLLQ
	case *REPORTING:
		return CodeREPORTING
	case *COOKIE:
		return CodeCOOKIE
	case *NSID:
		return CodeNSID
	case *PADDING:
		return CodePADDING
	case *EXPIRE:
		return CodeEXPIRE
	case *DAU:
		return CodeDAU
	case *DHU:
		return CodeDHU
	case *N3U:
		return CodeN3U
	case *TCPKEEPALIVE:
		return CodeTCPKEEPALIVE
	case *EDE:
		return CodeEDE
	case *SUBNET:
		return CodeSUBNET
	case *ESU:
		return CodeESU
	case *ZONEVERSION:
		return CodeZONEVERSION
	}
	if x, ok := o.(Typer); ok {
		return x.Type()
	}
	return CodeNone
}

// CodeToString is a map of strings for each EDNS0 RR type.
var CodeToString = map[uint16]string{
	CodeLLQ:          "LLQ",
	CodeREPORTING:    "REPORTING",
	CodeCOOKIE:       "COOKIE",
	CodeNSID:         "NSID",
	CodePADDING:      "PADDING",
	CodeEXPIRE:       "EXPIRE",
	CodeDAU:          "DAU",
	CodeDHU:          "DHU",
	CodeN3U:          "N3U",
	CodeTCPKEEPALIVE: "TCPKEEPALIVE",
	CodeEDE:          "EDE",
	CodeSUBNET:       "SUBNET",
	CodeESU:          "ESU",
	CodeZONEVERSION:  "ZONEVERSION",
}
