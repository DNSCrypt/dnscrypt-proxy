// Code generated by "go run msg_generate.go"; DO NOT EDIT.

package dns

import (
	"codeberg.org/miekg/dns/deleg"
	"codeberg.org/miekg/dns/internal/pack"
	"codeberg.org/miekg/dns/internal/unpack"
	"codeberg.org/miekg/dns/svcb"
	"golang.org/x/crypto/cryptobyte"
)

func (rr *NULL) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringAny(rr.Null, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NULL) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Null, err = unpack.StringAny(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NULL")
	}
	return nil
}

func (rr *CNAME) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Target, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *CNAME) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Target, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "CNAME")
	}
	return nil
}

func (rr *HINFO) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.String(rr.Cpu, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Os, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *HINFO) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Cpu, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Os, err = unpack.String(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "HINFO")
	}
	return nil
}

func (rr *MB) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Mb, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MB) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Mb, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MB")
	}
	return nil
}

func (rr *MG) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Mg, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MG) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Mg, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MG")
	}
	return nil
}

func (rr *MINFO) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Rmail, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Email, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MINFO) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Rmail, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.Email, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MINFO")
	}
	return nil
}

func (rr *MR) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Mr, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MR) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Mr, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MR")
	}
	return nil
}

func (rr *MF) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Mf, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MF) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Mf, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MF")
	}
	return nil
}

func (rr *MD) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Md, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MD) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Md, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MD")
	}
	return nil
}

func (rr *MX) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Mx, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *MX) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Mx, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "MX")
	}
	return nil
}

func (rr *AFSDB) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Subtype, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Hostname, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *AFSDB) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Subtype) {
		return unpack.ErrOverflow
	}
	rr.Hostname, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "AFSDB")
	}
	return nil
}

func (rr *X25) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.String(rr.PSDNAddress, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *X25) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.PSDNAddress, err = unpack.String(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "X25")
	}
	return nil
}

func (rr *ISDN) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.String(rr.Address, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.SubAddress, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *ISDN) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Address, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.SubAddress, err = unpack.String(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "ISDN")
	}
	return nil
}

func (rr *RT) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Host, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *RT) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Host, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "RT")
	}
	return nil
}

func (rr *NS) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Ns, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NS) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Ns, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NS")
	}
	return nil
}

func (rr *PTR) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Ptr, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *PTR) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Ptr, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "PTR")
	}
	return nil
}

func (rr *RP) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Mbox, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Txt, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *RP) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Mbox, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.Txt, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "RP")
	}
	return nil
}

func (rr *SOA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Ns, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Mbox, msg, off, compression, true)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Serial, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Refresh, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Retry, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Expire, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Minttl, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *SOA) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Ns, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.Mbox, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.ReadUint32(&rr.Serial) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Refresh) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Retry) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Expire) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Minttl) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "SOA")
	}
	return nil
}

func (rr *TXT) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringTxt(rr.Txt, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *TXT) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Txt, err = unpack.StringTxt(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "TXT")
	}
	return nil
}

func (rr *IPN) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint64(rr.Node, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *IPN) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint64(&rr.Node) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "IPN")
	}
	return nil
}

func (rr *SRV) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Priority, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Weight, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Port, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Target, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *SRV) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Priority) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Weight) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Port) {
		return unpack.ErrOverflow
	}
	rr.Target, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "SRV")
	}
	return nil
}

func (rr *NAPTR) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Order, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Flags, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Service, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Regexp, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Replacement, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NAPTR) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Order) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Flags, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Service, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Regexp, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Replacement, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NAPTR")
	}
	return nil
}

func (rr *CERT) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Type, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.KeyTag, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringBase64(rr.Certificate, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *CERT) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Type) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.KeyTag) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	rr.Certificate, err = unpack.StringBase64(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "CERT")
	}
	return nil
}

func (rr *DNAME) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Target, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *DNAME) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Target, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "DNAME")
	}
	return nil
}

func (rr *A) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.A(rr.Addr, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *A) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Addr, err = unpack.A(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "A")
	}
	return nil
}

func (rr *AAAA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.AAAA(rr.Addr, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *AAAA) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Addr, err = unpack.AAAA(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "AAAA")
	}
	return nil
}

func (rr *PX) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Map822, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Mapx400, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *PX) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Map822, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.Mapx400, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "PX")
	}
	return nil
}

func (rr *GPOS) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.String(rr.Longitude, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Latitude, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Altitude, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *GPOS) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Longitude, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Latitude, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Altitude, err = unpack.String(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "GPOS")
	}
	return nil
}

func (rr *LOC) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Version, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Size, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.HorizPre, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.VertPre, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Latitude, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Longitude, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Altitude, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *LOC) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Version) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Size) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.HorizPre) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.VertPre) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Latitude) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Longitude) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Altitude) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "LOC")
	}
	return nil
}

func (rr *RRSIG) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.TypeCovered, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Labels, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.OrigTTL, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Expiration, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Inception, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.KeyTag, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.SignerName, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = pack.StringBase64(rr.Signature, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *RRSIG) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.TypeCovered) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Labels) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.OrigTTL) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Expiration) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Inception) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.KeyTag) {
		return unpack.ErrOverflow
	}
	rr.SignerName, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.Signature, err = unpack.StringBase64(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "RRSIG")
	}
	return nil
}

func (rr *NSEC) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.NextDomain, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = packNSEC(rr.TypeBitMap, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NSEC) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.NextDomain, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.TypeBitMap, err = unpackNSEC(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NSEC")
	}
	return nil
}

func (rr *DS) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.KeyTag, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.DigestType, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Digest, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *DS) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.KeyTag) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.DigestType) {
		return unpack.ErrOverflow
	}
	rr.Digest, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "DS")
	}
	return nil
}

func (rr *KX) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Exchanger, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *KX) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Exchanger, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "KX")
	}
	return nil
}

func (rr *TA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.KeyTag, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.DigestType, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Digest, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *TA) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.KeyTag) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.DigestType) {
		return unpack.ErrOverflow
	}
	rr.Digest, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "TA")
	}
	return nil
}

func (rr *TALINK) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.PreviousName, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.NextName, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *TALINK) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.PreviousName, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.NextName, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "TALINK")
	}
	return nil
}

func (rr *SSHFP) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Type, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.FingerPrint, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *SSHFP) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Type) {
		return unpack.ErrOverflow
	}
	rr.FingerPrint, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "SSHFP")
	}
	return nil
}

func (rr *DNSKEY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Flags, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Protocol, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringBase64(rr.PublicKey, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *DNSKEY) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Flags) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Protocol) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	rr.PublicKey, err = unpack.StringBase64(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "DNSKEY")
	}
	return nil
}

func (rr *RKEY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Flags, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Protocol, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Algorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringBase64(rr.PublicKey, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *RKEY) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Flags) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Protocol) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Algorithm) {
		return unpack.ErrOverflow
	}
	rr.PublicKey, err = unpack.StringBase64(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "RKEY")
	}
	return nil
}

func (rr *NSAPPTR) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Ptr, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NSAPPTR) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Ptr, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NSAPPTR")
	}
	return nil
}

func (rr *NSEC3) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Hash, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Flags, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Iterations, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.SaltLength, msg, off)
	if err != nil {
		return off, err
	}
	// Only pack salt if value is not "-", i.e. empty
	if rr.Salt != "-" {
		off, err = pack.StringHex(rr.Salt, msg, off)
		if err != nil {
			return off, err
		}
	}
	off, err = pack.Uint8(rr.HashLength, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringBase32(rr.NextDomain, msg, off)
	if err != nil {
		return off, err
	}
	off, err = packNSEC(rr.TypeBitMap, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NSEC3) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Hash) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Flags) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Iterations) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.SaltLength) {
		return unpack.ErrOverflow
	}
	rr.Salt, err = unpack.StringHex(&s, int(rr.SaltLength))
	if err != nil {
		return err
	}
	if !s.ReadUint8(&rr.HashLength) {
		return unpack.ErrOverflow
	}
	rr.NextDomain, err = unpack.StringBase32(&s, int(rr.HashLength))
	if err != nil {
		return err
	}
	rr.TypeBitMap, err = unpackNSEC(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NSEC3")
	}
	return nil
}

func (rr *NSEC3PARAM) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Hash, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Flags, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Iterations, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.SaltLength, msg, off)
	if err != nil {
		return off, err
	}
	// Only pack salt if value is not "-", i.e. empty
	if rr.Salt != "-" {
		off, err = pack.StringHex(rr.Salt, msg, off)
		if err != nil {
			return off, err
		}
	}
	return off, nil
}

func (rr *NSEC3PARAM) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Hash) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Flags) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Iterations) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.SaltLength) {
		return unpack.ErrOverflow
	}
	rr.Salt, err = unpack.StringHex(&s, int(rr.SaltLength))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NSEC3PARAM")
	}
	return nil
}

func (rr *TKEY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Algorithm, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Inception, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint32(rr.Expiration, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Mode, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Error, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.KeySize, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Key, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.OtherLen, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.OtherData, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *TKEY) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Algorithm, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.ReadUint32(&rr.Inception) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint32(&rr.Expiration) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Mode) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Error) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.KeySize) {
		return unpack.ErrOverflow
	}
	rr.Key, err = unpack.StringHex(&s, int(rr.KeySize))
	if err != nil {
		return err
	}
	if !s.ReadUint16(&rr.OtherLen) {
		return unpack.ErrOverflow
	}
	rr.OtherData, err = unpack.StringHex(&s, int(rr.OtherLen))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "TKEY")
	}
	return nil
}

func (rr *RFC3597) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringHex(rr.Data, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *RFC3597) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Data, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "RFC3597")
	}
	return nil
}

func (rr *URI) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Priority, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Weight, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringAny(rr.Target, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *URI) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Priority) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Weight) {
		return unpack.ErrOverflow
	}
	rr.Target, err = unpack.StringAny(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "URI")
	}
	return nil
}

func (rr *DHCID) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringBase64(rr.Digest, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *DHCID) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Digest, err = unpack.StringBase64(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "DHCID")
	}
	return nil
}

func (rr *TLSA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Usage, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Selector, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.MatchingType, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Certificate, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *TLSA) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Usage) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Selector) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.MatchingType) {
		return unpack.ErrOverflow
	}
	rr.Certificate, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "TLSA")
	}
	return nil
}

func (rr *SMIMEA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Usage, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Selector, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.MatchingType, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Certificate, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *SMIMEA) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Usage) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Selector) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.MatchingType) {
		return unpack.ErrOverflow
	}
	rr.Certificate, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "SMIMEA")
	}
	return nil
}

func (rr *HIP) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.HitLength, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.PublicKeyAlgorithm, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.PublicKeyLength, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Hit, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringBase64(rr.PublicKey, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Names(rr.RendezvousServers, msg, off, compression)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *HIP) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.HitLength) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.PublicKeyAlgorithm) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.PublicKeyLength) {
		return unpack.ErrOverflow
	}
	rr.Hit, err = unpack.StringHex(&s, int(rr.HitLength))
	if err != nil {
		return err
	}
	rr.PublicKey, err = unpack.StringBase64(&s, int(rr.PublicKeyLength))
	if err != nil {
		return err
	}
	rr.RendezvousServers, err = unpack.Names(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "HIP")
	}
	return nil
}

func (rr *NINFO) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringTxt(rr.ZSData, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NINFO) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.ZSData, err = unpack.StringTxt(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NINFO")
	}
	return nil
}

func (rr *NID) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint64(rr.NodeID, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NID) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint64(&rr.NodeID) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NID")
	}
	return nil
}

func (rr *L32) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.A(rr.Locator32, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *L32) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Locator32, err = unpack.A(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "L32")
	}
	return nil
}

func (rr *L64) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint64(rr.Locator64, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *L64) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint64(&rr.Locator64) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "L64")
	}
	return nil
}

func (rr *LP) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Preference, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Fqdn, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *LP) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Preference) {
		return unpack.ErrOverflow
	}
	rr.Fqdn, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "LP")
	}
	return nil
}

func (rr *EUI48) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint48(rr.Address, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *EUI48) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint48(&rr.Address) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "EUI48")
	}
	return nil
}

func (rr *EUI64) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint64(rr.Address, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *EUI64) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint64(&rr.Address) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "EUI64")
	}
	return nil
}

func (rr *CAA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint8(rr.Flag, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.String(rr.Tag, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringAny(rr.Value, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *CAA) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint8(&rr.Flag) {
		return unpack.ErrOverflow
	}
	rr.Tag, err = unpack.String(&s)
	if err != nil {
		return err
	}
	rr.Value, err = unpack.StringAny(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "CAA")
	}
	return nil
}

func (rr *UID) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint32(rr.Uid, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *UID) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint32(&rr.Uid) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "UID")
	}
	return nil
}

func (rr *GID) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint32(rr.Gid, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *GID) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint32(&rr.Gid) {
		return unpack.ErrOverflow
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "GID")
	}
	return nil
}

func (rr *UINFO) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.String(rr.Uinfo, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *UINFO) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Uinfo, err = unpack.String(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "UINFO")
	}
	return nil
}

func (rr *EID) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringHex(rr.Endpoint, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *EID) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Endpoint, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "EID")
	}
	return nil
}

func (rr *NIMLOC) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringHex(rr.Locator, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *NIMLOC) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Locator, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NIMLOC")
	}
	return nil
}

func (rr *OPENPGPKEY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.StringBase64(rr.PublicKey, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *OPENPGPKEY) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.PublicKey, err = unpack.StringBase64(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "OPENPGPKEY")
	}
	return nil
}

func (rr *CSYNC) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint32(rr.Serial, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Flags, msg, off)
	if err != nil {
		return off, err
	}
	off, err = packNSEC(rr.TypeBitMap, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *CSYNC) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint32(&rr.Serial) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Flags) {
		return unpack.ErrOverflow
	}
	rr.TypeBitMap, err = unpackNSEC(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "CSYNC")
	}
	return nil
}

func (rr *ZONEMD) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint32(rr.Serial, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Scheme, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Hash, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.Digest, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *ZONEMD) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint32(&rr.Serial) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Scheme) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Hash) {
		return unpack.ErrOverflow
	}
	rr.Digest, err = unpack.StringHex(&s, len(s))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "ZONEMD")
	}
	return nil
}

func (rr *SVCB) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Priority, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Target, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = svcb.Pack(rr.Value, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *SVCB) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Priority) {
		return unpack.ErrOverflow
	}
	rr.Target, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	rr.Value, err = svcb.Unpack(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "SVCB")
	}
	return nil
}

func (rr *DELEG) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = deleg.Pack(rr.Value, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *DELEG) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Value, err = deleg.Unpack(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "DELEG")
	}
	return nil
}

func (rr *DSYNC) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Uint16(rr.Type, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint8(rr.Scheme, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Port, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Name(rr.Target, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *DSYNC) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.ReadUint16(&rr.Type) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint8(&rr.Scheme) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Port) {
		return unpack.ErrOverflow
	}
	rr.Target, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "DSYNC")
	}
	return nil
}

func (rr *TSIG) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = pack.Name(rr.Algorithm, msg, off, compression, false)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint48(rr.TimeSigned, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Fudge, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.MACSize, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.MAC, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.OrigID, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.Error, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.Uint16(rr.OtherLen, msg, off)
	if err != nil {
		return off, err
	}
	off, err = pack.StringHex(rr.OtherData, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *TSIG) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Algorithm, err = unpack.Name(&s, msgBuf)
	if err != nil {
		return err
	}
	if !s.ReadUint48(&rr.TimeSigned) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Fudge) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.MACSize) {
		return unpack.ErrOverflow
	}
	rr.MAC, err = unpack.StringHex(&s, int(rr.MACSize))
	if err != nil {
		return err
	}
	if !s.ReadUint16(&rr.OrigID) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.Error) {
		return unpack.ErrOverflow
	}
	if !s.ReadUint16(&rr.OtherLen) {
		return unpack.ErrOverflow
	}
	rr.OtherData, err = unpack.StringHex(&s, int(rr.OtherLen))
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "TSIG")
	}
	return nil
}

func (rr *NXNAME) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return off, nil
}

func (rr *NXNAME) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "NXNAME")
	}
	return nil
}

func (rr *SPF) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.TXT.pack(msg, off, compression)
}
func (rr *SPF) unpack(data, msgBuf []byte) (err error) {
	return rr.TXT.unpack(data, msgBuf)
}
func (rr *AVC) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.TXT.pack(msg, off, compression)
}
func (rr *AVC) unpack(data, msgBuf []byte) (err error) {
	return rr.TXT.unpack(data, msgBuf)
}
func (rr *WALLET) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.TXT.pack(msg, off, compression)
}
func (rr *WALLET) unpack(data, msgBuf []byte) (err error) {
	return rr.TXT.unpack(data, msgBuf)
}
func (rr *CLA) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.TXT.pack(msg, off, compression)
}
func (rr *CLA) unpack(data, msgBuf []byte) (err error) {
	return rr.TXT.unpack(data, msgBuf)
}
func (rr *SIG) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.RRSIG.pack(msg, off, compression)
}
func (rr *SIG) unpack(data, msgBuf []byte) (err error) {
	return rr.RRSIG.unpack(data, msgBuf)
}
func (rr *NXT) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.NSEC.pack(msg, off, compression)
}
func (rr *NXT) unpack(data, msgBuf []byte) (err error) {
	return rr.NSEC.unpack(data, msgBuf)
}
func (rr *DLV) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.DS.pack(msg, off, compression)
}
func (rr *DLV) unpack(data, msgBuf []byte) (err error) {
	return rr.DS.unpack(data, msgBuf)
}
func (rr *CDS) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.DS.pack(msg, off, compression)
}
func (rr *CDS) unpack(data, msgBuf []byte) (err error) {
	return rr.DS.unpack(data, msgBuf)
}
func (rr *KEY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.DNSKEY.pack(msg, off, compression)
}
func (rr *KEY) unpack(data, msgBuf []byte) (err error) {
	return rr.DNSKEY.unpack(data, msgBuf)
}
func (rr *CDNSKEY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.DNSKEY.pack(msg, off, compression)
}
func (rr *CDNSKEY) unpack(data, msgBuf []byte) (err error) {
	return rr.DNSKEY.unpack(data, msgBuf)
}
func (rr *OPT) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	off, err = packOPT(rr.Options, msg, off)
	if err != nil {
		return off, err
	}
	return off, nil
}

func (rr *OPT) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	rr.Options, err = unpackOPT(&s)
	if err != nil {
		return err
	}
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "OPT")
	}
	return nil
}

func (rr *RESINFO) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.TXT.pack(msg, off, compression)
}
func (rr *RESINFO) unpack(data, msgBuf []byte) (err error) {
	return rr.TXT.unpack(data, msgBuf)
}
func (rr *HTTPS) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.SVCB.pack(msg, off, compression)
}
func (rr *HTTPS) unpack(data, msgBuf []byte) (err error) {
	return rr.SVCB.unpack(data, msgBuf)
}
func (rr *DELEGI) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return rr.DELEG.pack(msg, off, compression)
}
func (rr *DELEGI) unpack(data, msgBuf []byte) (err error) {
	return rr.DELEG.unpack(data, msgBuf)
}
func (rr *ANY) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return off, nil
}

func (rr *ANY) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "ANY")
	}
	return nil
}

func (rr *AXFR) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return off, nil
}

func (rr *AXFR) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "AXFR")
	}
	return nil
}

func (rr *IXFR) pack(msg []byte, off int, compression map[string]uint16) (off1 int, err error) {
	return off, nil
}

func (rr *IXFR) unpack(data, msgBuf []byte) (err error) {
	s := cryptobyte.String(data)
	if !s.Empty() {
		return unpack.Errorf("trailing record data: %s", "IXFR")
	}
	return nil
}
